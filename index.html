<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>RA1811028010036</title>

<link rel="stylesheet" media="screen" href="style.css?v=8may2013">
	<link rel="alternate" type="application/rss+xml" title="RSS" href="file:///C:/Users/User/Desktop/web/purboshi.html">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="author" content="Dave Shea">
	<meta name="description" content="A demonstration of what can be accomplished visually through CSS-based design.">
	<meta name="robots" content="all">


	<!--[if lt IE 9]>
	<script src="script/html5shiv.js"></script>
	<![endif]-->
</head>

<!--



	View source is a feature, not a bug. Thanks for your curiosity and
	interest in participating!

	Here are the submission guidelines for the new and improved csszengarden.com:

	- CSS3? Of course! Prefix for ALL browsers where necessary.
	- go responsive; test your layout at multiple screen sizes.
	- your browser testing baseline: IE9+, recent Chrome/Firefox/Safari, and iOS/Android
	- Graceful degradation is acceptable, and in fact highly encouraged.
	- use classes for styling. Don't use ids.
	- web fonts are cool, just make sure you have a license to share the files. Hosted 
	  services that are applied via the CSS file (ie. Google Fonts) will work fine, but
	  most that require custom HTML won't. TypeKit is supported, see the readme on this
	  page for usage instructions: https://github.com/mezzoblue/csszengarden.com/

	And a few tips on building your CSS file:

	- use :first-child, :last-child and :nth-child to get at non-classed elements
	- use ::before and ::after to create pseudo-elements for extra styling
	- use multiple background images to apply as many as you need to any element
	- use the Kellum Method for image replacement, if still needed. http://goo.gl/GXxdI
	- don't rely on the extra divs at the bottom. Use ::before and ::after instead.

		
-->

<body id="css-zen-garden">
<div class="page-wrapper">

	<section class="intro" id="zen-intro">
		<header role="banner">
			<h1>Purboshi Creations</h1>
			
		</header>

		<div class="summary" id="zen-summary" role="article">
			<p>Python is used successfully in thousands of real-world business applications around the world!</p>
			
		</div>
		<div>
<h1 >PYTHON LEARNING</h1>
</div>
<div  >
		
			<h2  >
				<p> <abbr> -PURBOSHI DAS  (RA1811028010036)</abbr> </p> 
			
			</h2>

		
</div>
		<div class="preamble" id="zen-preamble" role="article">
			<h3>Introduction</h3>
			<p>Python is an interpreted, high-level, general-purpose programming language. Created by Guido van Rossum and first released in 1991, Python's design philosophy emphasizes code readability with its notable use of significant whitespace. Its language constructs and object-oriented approach aim to help programmers write clear, logical code for small and large-scale projects.
			</p>
			
		</div>
	</section>

	<div class="main supporting" id="zen-supporting" role="main">
		<div class="explanation" id="zen-explanation" role="article">
			<h3>Programming Paradigms</h3>
			<p>Programming paradigms are a way to classify programming languages based on their features. Languages can be classified into multiple paradigms.

</p>
			<p>Some paradigms are concerned mainly with implications for the execution model of the language, such as allowing side effects, or whether the sequence of operations is defined by the execution model. Other paradigms are concerned mainly with the way that code is organized, such as grouping a code into units along with the state that is modified by the code. Yet others are concerned mainly with the style of syntax and grammar.</p>
		</div>

		<div class="participation" id="zen-participation" role="article">
			<h3>Overview</h3>
			<p>Just as software engineering (as a process) is defined by differing methodologies, so the programming languages (as models of computation) are defined by differing paradigms. Some languages are designed to support one paradigm (Smalltalk supports object-oriented programming, Haskell supports functional programming), while other programming languages support multiple paradigms (such as Object Pascal, C++, Java, JavaScript, C#, Scala, Visual Basic, Common Lisp, Scheme, Perl, PHP, Python, Ruby, Wolfram Language, Oz, and F#). For example, programs written in C++, Object Pascal or PHP can be purely procedural, purely object-oriented, or can contain elements of both or other paradigms. Software designers and programmers decide how to use those paradigm elements.</p>
			
		</div>

		<div class="benefits" id="zen-benefits" role="article">
			<h3>Criticism</h3>
			<p>Some programming language researchers criticise the notion of paradigms as a classification of programming languages, e.g. Harper, and Krishnamurthi. They argue that many programming languages cannot be strictly classified into one paradigm, but rather include features from several paradigms. See Comparison of multi-paradigm programming languages.</p>
		</div>

		<div class="requirements" id="zen-requirements" role="article">
			<h3>History</h3>
			<p>Different approaches to programming have developed over time, being identified as such either at the time or retrospectively. An early approach consciously identified as such is structured programming, advocated since the mid 1960s. The concept of a "programming paradigm" as such dates at least to 1978, in the Turing Award lecture of Robert W. Floyd, entitled The Paradigms of Programming, which cites the notion of paradigm as used by Thomas Kuhn in his The Structure of Scientific Revolutions (1962).</p>
		</div>

			<div class="benefits" id="zen-benefits" role="article">
				<h3 >Types of Programming Paradigms</h3>
			<ol>
				<li id="section1"><h4>Structural</h4><p>Structured programming is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making extensive use of the structured control flow constructs of selection (if/then/else) and repetition (while and for), block structures, and subroutines.<br>It is possible to do structured programming in any programming language, though it is preferable to use something like a procedural programming language. Some of the languages initially used for structured programming include: ALGOL, Pascal, PL/I and Ada, but most new procedural programming languages since that time have included features to encourage structured programming, and sometimes deliberately left out features – notably GOTO – in an effort to make unstructured programming more difficult. Structured programming (sometimes known as modular programming[citation needed]) enforces a logical structure on the program being written to make it more efficient and easier to understand and modify.<br>
					<div>Some important points:
						<ul>
							<li>Program is made as a single structure.</li>
							<li>Code will execute the instruction by instruction one after the other.</li>
							<li>It doesn’t support the possibility of jumping from one instruction to some other with the help of any statement like GOTO,etc.</li>
							<li>The structured program consists of well structured and separated modules. But the entry and exit in a Structured program is a single-time event. It means that the program uses single-entry and single-exit elements.
</li>
<li>Instructions in this approach will be executed in a serial and structured manner. The languages that support Structured
programming approach are: C, C++, Java, C# ..etc</li>
</ul>
The structured program mainly consists of three types of elements:<ol>
<li>
Selection Statements</li><li>

Sequence Statements</li><li>

Iteration Statements</li></ol></div>
					<a href="#back to top">back to top</a></p><br></li>

				<li id="section2"><h4>Procedural</h4><p>Procedural programming is a programming paradigm, derived from structured programming,[citation needed] based on the concept of the procedure call. Procedures, also known as routines, subroutines, or functions, simply contain a series of computational steps to be carried out. Any given procedure might be called at any point during a program's execution, including by other procedures or itself. The first major procedural programming languages appearEncapsulationed circa 1957–1964, including Fortran, ALGOL, COBOL, PL/I and BASIC.Pascal and C were published circa 1970–1972.<br>
<div>Some important points:
	<ul>
		<li>
	High level languages such as COBOL, FORTRAN and C, is commonly known as procedure oriented programming(POP). In the
procedure oriented programming, program is divided into sub programs or modules and then assembled to form a complete
program. These modules are called functions.
</li><li>
The problem is viewed as a sequence of things to be done.</li>
<li>
The primary focus is on functions.
</li><li>
Procedure-oriented programming basically consists of writing a list of instructions for the computer to follow and organizing
these instructions into groups known as functions.
</li><li>
In a multi-function program, many important data items are placed as global so that they may be accessed by all functions.
Each function may have its own local data. If a function made any changes to global data, these changes will reflect in other
functions. Global data are more unsafe to an accidental change by a function. In a large program it is very difficult to identify
what data is used by which function.
</li><li>
This approach does not model real world problems. This is because functions are action-oriented and do not really correspond
to the elements of the problem.</li></ul></div>
<div>Characteristics of Procedure-Oriented Programming:
	<ul>
<li>		Emphasis is on doing things.
</li><li>
Large programs are divided into smaller programs known as functions.
</li><li>
Most of the functions share global data.
</li><li>
Data move openly around the system from function to function.
</li><li>
Functions transform data from one form to another.
</li><li>
Employs top-down approach in program design.
	</li></ul>
	</div>

					<a href="#back to top">back to top</a></p><br></li>

				<li id="section3"><h4>Object Oriented</h4><p>Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which can contain data, in the form of fields (often known as attributes or properties), and code, in the form of procedures (often known as methods). A feature of objects is an object's procedures that can access and often modify the data fields of the object with which they are associated (objects have a notion of "this" or "self").<br>
<div>Characteristics:
	<ul>
		<li>Emphasis is on data rather than procedure.</li>

<li>Programs are divided into objects.</li>
<li>
Data structures are designed such that they characterize the objects.</li>
<li>
Functions that operate on the data of an object are tied together in the data structure.
</li><li>
Data is hidden and can not be accessed by external functions.
</li><li>
Objects may communicate with each other through functions.
</li><li>
New data and functions can be added easily whenever necessary.
</li><li>
Follows bottom-up approach in program design.</li>
</ul></div><br>
					Some basic properties of OOPS:
				<div><ul>
					<li>Objects</li>
					<li>Classes</li>
					<li>Data Abstraction and Encapsulation</li>
					<li>Inheritance</li>
					<li>Polymorphism</li>
					<li>Overloading</li>
					<li>Dynamic Binding</li>
					<li>Message Passing</li>
				</ul></div>
				<a href="#back to top">back to top</a></p><br></li>

				<li id="section4"><h4>Event Driven</h4><p>In computer programming, event-driven programming is a programming paradigm in which the flow of the program is determined by events such as user actions (mouse clicks, key presses), sensor outputs, or messages from other programs or threads. Event-driven programming is the dominant paradigm used in graphical user interfaces and other applications (e.g., JavaScript web applications) that are centered on performing certain actions in response to user input. This is also true of programming for device drivers (e.g., P in USB device driver stacks).<br>In an event-driven application, there is generally a main loop that listens for events, and then triggers a callback function when one of those events is detected. In embedded systems, the same may be achieved using hardware interrupts instead of a constantly running main loop. Event-driven programs can be written in any programming language, although the task is easier in languages that provide high-level abstractions, such as await and closures.<br>
					<div>
						<ul>
							<li>Event-driven programming is a programming paradigm in which the flow of program execution is determined by events - for example a user
action such as a mouse click, key press, or a message from the operating system or another program.</li><li>

An event-driven application is designed to detect events as they occur, and then deal with them using an appropriate event-handling
procedure.</li><li>

In a typical modern event-driven program, there is no discernible flow of control. The main routine is an event-loop that waits for an event to
occur, and then invokes the appropriate event-handling routine.
</li><li>
Event callback is a function that is invoked when something significant happens like when click event is performed by user or the result of
database query is available.
</li>
<ol><li>
Event Handlers: Event handlers is a type of function or method that run a specific action when a specific event is triggered. For example, it could
be a button that when user click it, it will display a message, and it will close the message when user click the button again, this is an event
handler.
</li><li>
Trigger Functions: Trigger functions in event-driven programming are a functions that decide what code to run when there are a specific event
occurs, which are used to select which event handler to use for the event when there is specific event occurred.
</li><li>
Events: Events include mouse, keyboard and user interface, which events need to be triggered in the program in order to happen, that mean
user have to interacts with an object in the program, for example, click a button by a mouse, use keyboard to select a button and etc.
		</li></ol>			</div>

					<a href="#back to top">back to top</a></p><br> </li>

				<li id="section5"><h4>Declarative</h4><p>In computer science, declarative programming is a programming paradigm—a style of building the structure and elements of computer programs—that expresses the logic of a computation without describing its control flow.<br>Many languages that apply this style attempt to minimize or eliminate side effects by describing what the program must accomplish in terms of the problem domain, rather than describe how to accomplish it as a sequence of the programming language primitives[2] (the how being left up to the language's implementation). This is in contrast with imperative programming, which implements algorithms in explicit steps.<br>Declarative programming often considers programs as theories of a formal logic, and computations as deductions in that logic space. Declarative programming may greatly simplify writing parallel programs.<br>Common declarative languages include those of database query languages (e.g., SQL, XQuery), regular expressions, logic programming, functional programming, and configuration management systems.<br>
					<div>Some important points:
						<ul>
							<li>Declarative programming is a programming paradigm that expresses the logic of a computation without describing its control flow.</li>
							<li>

This paradigm often considers programs as theories of a formal logic, and computations as deductions in that logic space.
</li><li>
Declarative programming is often defined as any style of programming that is not imperative.
</li><li>
Common declarative languages include those of database query languages (SQL), logic programming, functional programming,
etc.
</li><li>
A program that describes what computation should be performed and not how to compute it. Non-imperative, non-procedural.
</li><li>
Any programming language that lacks side effects(example: a function might modify a global variable or static variable, modify
one of its arguments, raise an exception,etc).
</li><li>
A language with a clear correspondence to mathematical logic.
</li></ul>

Declarative Programming Paradigm
<ul>
	<li>
A program that describes what computation should be performed and not how to compute it .
</li><li>
Any programming language that lacks side effects (or more specifically, is referentially transparent).
</li><li>
A language with a clear correspondence to mathematical logic
<ul>
Here, the term side effect was mentioned.
<li>
A function or expression is said to have a side effect if, in addition to returning a value, it also modifies some state or has an
observable interaction with calling functions or the outside world. For example, a function might modify a global variable or
static variable, modify one of its arguments, raise an exception, write data to a display or file, read data, etc.
</li><li>
Examples of declarative languages are HTML, XML, CSS, JSON and SQL, and there are more
</li></ul></li></ul>
<br></div>
<div>
SQL Elements
<br><p>
SQL is the
standard language used to communicate with a relational database.
<br>
It can be used to retrieve data from a database using a query but it can also be used to create, manage, destroy as well as modify
their structure and contents.</p>

The language is subdivided into several language elements, including:
<ul>
	<li>
Clauses
</li><li>
Expressions
</li><li>
Predicates
</li><li>
Queries
</li><li>
Statements
</li></ul>
</div>
						<a href="#back to top">back to top</a></p><br></li>

				<li id="section6"><h4>Imperative</h4><p>The imperative programming paradigm assumes that the computer can maintain through environments of variables any changes in a computation process. Computations are performed through a guided sequence of steps, in which these variables are referred to or changed. The order of the steps is crucial, because a given step will have different consequences depending on the current values of variables when the step is executed.<br>Imperative Languages:<br>
					Popular programming languages are imperative more often than they are any other paradigm studies in this course. There are two reasons for such popularity:<div>
						<ol>
							<li>the imperative paradigm most closely resembles the actual machine itself, so the programmer is much closer to the machine;</li>
							<li>because of such closeness, the imperative paradigm was the only one efficient enough for widespread use until recently;</li></ol></div><br>
							<div>Advantages:
								<ul>
									<li>efficient;</li>
									<li>close to the machine;</li>
									<li>popular;</li>
									<li>familiar.</li>
								</ul>
								Disadvantages:
								<ul>
									<li>The semantics of a program can be complex to understand or prove, because of referential transparency does not hold(due to side effects)</li>
									<li>Side effects also make debugging harder;</li>
									<li>Abstration is more limitted than with some paradigms;</li>
									<li>Order is crucial, which doesn't always suit itself to problems.</li></ul></div><a href="#back to top">back to top</a><br></p></li>

				<li id="section7"><h4>Parallel</h4><p>In computing, a parallel programming model is an abstraction of parallel computer architecture, with which it is convenient to express algorithms and their composition in programs. The value of a programming model can be judged on its generality: how well a range of different problems can be expressed for a variety of different architectures, and its performance: how efficiently the compiled programs can execute.The implementation of a parallel programming model can take the form of a library invoked from a sequential language, as an extension to an existing language, or as an entirely new language.<br>Consensus around a particular programming model is important because it leads to different parallel computers being built with support for the model, thereby facilitating portability of software. In this sense, programming models are referred to as bridging between hardware and software.<br></p>
<div>
	A system is said to be parallel if it can support two or more actions executing simultaneously i.e., multiple actions are
simultaneously executed in parallel systems.<br>

The evolution of parallel processing, even if slow, gave rise to a considerable variety of programming paradigms.<br>

Parallelism Types:
<ul>
	<li>
Explicit Parallelism
</li><li>
Implicit Parallelism
</li></ul></div>
<br>
<div>
	Explicit parallelism
<ul><li>
Explicit Parallelism is characterized by the presence of explicit constructs in the programming language, aimed at describing (to
a certain degree of detail) the way in which the parallel computation will take place.
</li><li>
A wide range of solutions exists within this framework. One extreme is represented by the ``ancient'' use of basic, low level
mechanisms to deal with parallelism--like fork/join primitives, semaphores, etc--eventually added to existing programming
languages. Although this allows the highest degree of flexibility (any form of parallel control can be implemented in terms of
the basic low level primitives gif), it leaves the additional layer of complexity completely on the shoulders of the programmer,
making his task extremely complicate.</li></ul>
</div>
<br>
<div>
	Implicit Parallelism
<ul><li>
Allows programmers to write their programs without any concern about the exploitation of parallelism. Exploitation of
parallelism is instead automatically performed by the compiler and/or the runtime system. In this way the parallelism is
transparent to the programmer maintaining the complexity of software development at the same level of standard sequential
programming.
</li><li>
Extracting parallelism implicitly is not an easy task. For imperative programming languages, the complexity of the problem is
almost prohibitively and allows positive results only for restricted sets of applications (e.g., applications which perform
intensive operations on arrays.
</li><li>
Declarative Programming languages, and in particular Functional and Logic languages, are characterized by a very high level of
abstraction, allowing the programmer to focus on what the problem is and leaving implicit many details of how the problem
should be solved.
</li><li>
Declarative languages have opened new doors to automatic exploitation of parallelism. Their focusing on a high level
description of the problem and their mathematical nature turned into positive properties for implicit exploitation of
parallelism.</li></ul></div>
<div><br>
	Methods for parallelism
<ul>
There are many methods of programming parallel computers. Two of the most common are message passing and data parallel.
<li>
Message Passing - the user makes calls to libraries to explicitly share information between processors.
</li><li>
Data Parallel - data partitioning determines parallelism
</li><li>
Shared Memory - multiple processes sharing common memory space
</li><li>
Remote Memory Operation - set of processes in which a process can access the memory of another process without its
participation
</li><li>
Threads - a single process having multiple (concurrent) execution paths
</li><li>
Combined Models - composed of two or more of the above.
</li></ul>
	</div>
					<a href="#back to top">back to top</a><br></li>

				<li id="section8"><h4>Concurrent</h4><p>Concurrent computing is a form of computing in which several computations are executed concurrently—during overlapping time periods—instead of sequentially, with one completing before the next starts.<br>This is a property of a system—whether a program, computer, or a network—where there is a separate execution point or "thread of control" for each process. A concurrent system is one where a computation can advance without waiting for all other computations to complete.<br>Concurrent computing is a form of modular programming. In its paradigm an overall computation is factored into subcomputations that may be executed concurrently.<br>Concurrent computations may be executed in parallel,[2][5] for example, by assigning each process to a separate processor or processor core, or distributing a computation across a network. In general, however, the languages, tools, and techniques for parallel programming might not be suitable for concurrent programming, and vice versa<br>

					<div>Some important points:
						<ul><li>
Computing systems model the world, and the world contains actors that execute independently of, but communicate with,
each other. In modelling the world, many (possibly) parallel executions have to be composed and coordinated, and that's
where the study of concurrency comes in.</li>
<li>

There are two common models for concurrent programming: shared memory and message passing.
<ol><li>
Shared memory. In the shared memory model of concurrency, concurrent modules interact by reading and writing
shared objects in memory.
</li><li>
Message passing. In the message-passing model, concurrent modules interact by sending messages to each other
through a communication channel. Modules send off messages, and incoming messages to each module are queued up
for handling.</li></ol></ul>
<br>
Issues Concurrent Programming Paradigm :-
</div><br>
<div>
Concurrent programming is programming with multiple tasks. The major issues of concurrent programming are:
<ul><li>
Sharing computational resources between the tasks;
</li><li>
Interaction of the tasks.</li></ul><br>

Objects shared by multiple tasks have to be safe for concurrent access. Such objects are called protected. Tasks accessing such an
object interact with each other indirectly through the object.<br>

An access to the protected object can be:<ul><li>

Lock-free, when the task accessing the object is not blocked for a considerable time;</li><li>

Blocking, otherwise.</li></ul><br>

Blocking objects can be used for task synchronization. To the examples of such objects belong:
<ol><li>
Events;</li><li>

Mutexes and semaphores;
</li><li>
Waitable timers;
</li><li>
Queues</li></ol>
					</div><br><br>

					<div>
						Synchronization in Python :-<br>
						<ol><li>

Locks:<br>

Locks are perhaps the simplest synchronization primitives in Python. A Lock has only two states — locked and unlocked
(surprise). It is created in the unlocked state and has two principal methods — acquire() and release(). The acquire() method locks
the Lock and blocks execution until the release() method in some other co-routine sets it to unlocked.
</li><li>
R-Locks:<br>

R-Lock class is a version of simple locking that only blocks if the lock is held by another thread. While simple locks will block if
the same thread attempts to acquire the same lock twice, a re-entrant lock only blocks if another thread currently holds the lock.
</li><li>
Semaphore:<br>

A semaphore has an internal counter rather than a lock flag, and it only blocks if more than a given number of threads have
attempted to hold the semaphore. Depending on how the semaphore is initialized, this allows multiple threads to access the same
code section simultaneously.</li></ol>
					</div>

					<a href="#back to top">back to top</a></p><br></li>

				<li id="section9"><h4>Functional</h4><p>Functional programming is a programming paradigm in which we try to bind everything in pure mathematical functions style. It is a declarative type of programming style. Its main focus is on “what to solve” in contrast to an imperative style where the main focus is “how to solve”. It uses expressions instead of statements. An expression is evaluated to produce a value whereas a statement is executed to assign variables.<br>Functional Languages<br><p>
Functional languages are created based on the functional paradigm. Such languages permit functional solutions to problems by permitting a programmer to treat functions as first-class objects(they can be treated as data, assumed to have the value of what they return; therefore, they can be passed to other functions as arguments or returned from functions).</p>
					<div>Often functional programs are:
				<ul>
					<li>Easier to read.</li>
					<li>Easier to debug and maintain.</li>
					<li>Easier to parallelize.</li>
				</ul>

					Useful features:
					<ul>
						<li>Hindley–Milner type system.</li>
						<li>Lazy evaluation.</li>
						<li>Closures.</li>
					</ul>
					All computations are implemented through functions: functions are first-class citizens.<br>Main building blocks:
					<ul>
						<li>Immutability: no variables gets changed (no side effects). In some sense, there are no variables.</li>
						<li>Recursions.</li>
						<li>Curried functions.</li>
					    <li>Higher-order functions: compositions ('operators in functional analysis).</li>
					
				</ul></div><br>
				<div>Advantages:
	<ol>The following are desirable properties of a functional language:
		<li>The high level of abstraction, especially when functions are used, supresses many of the details of programming and thus removes the possibility of commiting many classes of errors;</li>
		<li>The lack of dependence on assignment operations, allowing programs to be evaluated in many different orders. This evaluation order independence makes function-oriented languages good candidates for programming massively parallel computers;</li>
		<li>The absence of assignment operations makes the function-oriented programs much more amenable to mathematical proof and analysis than are imperative programs, because functional programs possess referential transparency.</li>
	</ol></div><div>
	Disadvantages:<ul>
			<li>Perhaps less efficiencey</li>
			<li>Problems involving many variables or a lot of sequential activity are sometimes easier to handle imperatively or with object-oriented programming.</li>
	</ul></div>
				<a href="#back to top">back to top</a></p><br>
			</li>

				<li id="section10"><h4>Logic</h4><p>
The Logical Paradigm takes a declarative approach to problem-solving. Various logical assertions about a situation are made, establishing all known facts. Then queries are made. The role of the computer becomes maintaining data and logical deduction.<br>Logical Paradigm Programming<br><div>
A logical program is divided into three sections:
<ul>
	<li>a series of definitions/declarations that define the problem domain</li>
	<li>statements of relevant facts</li>
	<li>statement of goals in the form of a query</li>
</ul>
Any deducible solution to a query is returned. The definitions and declarations are constructed entirely from relations. i.e. X is a member of Y or X is in the internal between a and b etc.
</div><br>
<div>Advantages:
	<ol>The advantages of logic oriented programming are bifold:
		<li>The system solves the problem, so the programming steps themselves are kept to a minimum;</li>
		<li>Proving the validity of a given program is simple.</li>
	</ol></div><div>
	Disadvantages:<ul>
			<li>Perhaps less efficiencey</li>
			<li>Problems involving many variables or a lot of sequential activity are sometimes easier to handle imperatively or with object-oriented programming.</li>
	</ul></div><a href="#back to top">back to top</a></p><br></li>

				<li id="section11"><h4>Dependent</h4><p>In computer science and logic, a dependent type is a type whose definition depends on a value. It is an overlapping feature of type theory and type systems. In intuitionistic type theory, dependent types are used to encode logic's quantifiers like "for all" and "there exists". In functional programming languages like Agda, ATS, Coq, F*, Epigram, and Idris, dependent types may help reduce bugs by enabling the programmer to assign types that further restrain the set of possible implementations.<br>Two common examples of dependent types are dependent functions and dependent pairs. The return type of a dependent function may depend on the value (not just type) of one of its arguments. For instance, a function that takes a positive integer where the array length is part of the type of the array. A dependent pair may have a second value of which the type depends on the first value. Sticking with the array example, a dependent pair may be used to pair an array with its length in a type-safe way.<br>Dependent types add complexity to a type system. Deciding the equality of dependent types in a program may require computations. If arbitrary values are allowed in dependent types, then deciding type equality may involve deciding whether two arbitrary programs produce the same result; hence type checking may become undecidable.<br><div>
					<ul>
A constant problem:
<li>
Writing a correct computer program is hard and proving that a program is correct is even harder
</li><li>
Dependent Types allow us to write programs and know they are correct before running them.
</li><li>
dependent types: you can specify types that can check the value of your variables at compile time</li></ul><br>
In computer science and logic, a dependent type is a type whose definition depends on a value.
<br>
It is an overlapping feature of type theory and type systems.
<br>
Used to encode logic's quantifiers like "for all" and "there exists".
<br>
Dependent types may help reduce bugs by enabling the programmer to assign types that further restrain the set of possible
implementations.<br></div>


					<a href="#back to top">back to top</a></p><br></li>

				<li id="section12"><h4>Network</h4><p>A programming language provides abstractions and ways to compose those abstractions.The programming languages you are familiar with are models of computer systems.They provide abstractions for data and computation.<br>
<div>
The Network paradigm involves thinking of computing in terms of a client, who is essentially in need of some type of information,
and a server, who has lots of information and is just waiting to hand it out. Typically, a client will connect to a server and query for
certain information. The server will go off and find the information and then return it to the client.<br>

In the context of the Internet, clients are typically run on desktop or laptop computers attached to the Internet looking for
information, whereas servers are typically run on larger computers with certain types of information available for the clients to
retrieve. The Web itself is made up of a bunch of computers that act as Web servers; they have vast amounts of HTML pages and
related data available for people to retrieve and browse. Web clients are used by those of us who connect to the Web servers and
browse through the Web pages.
<br>
Network programming uses a particular type of network communication known as sockets. A socket is a software abstraction for an
input or output medium of communication.
<br>
</div><br><div><p>
Socket:</p>
<ul>
	<li>
A socket is a software abstraction for an input or output medium of communication.
</li><li>
Sockets allow communication between processes that lie on the same machine, or on different machines working in diverse
environment and even across different continents.
</li><li>
A socket is the most vital and fundamental entity. Sockets are the end-point of a two-way communication link.
</li><li>
An endpoint is a combination of IP address and the port number.
</li></ul>

For Client-Server communication,
<ul>
	<li>
Sockets are to be configured at the two ends to initiate a connection,
</li><li>
Listen for incoming messages
</li><li>
Send the responses at both ends
</li><li>
Establishing a bidirectional communication.
</li></ul></div><br>
<div>
Socket Types
<ul>
	<li>
	Datagram Socket:<br>
<p>
A datagram is an independent, self-contained piece of information sent over a network whose arrival, arrival time, and content
are not guaranteed. A datagram socket uses User Datagram Protocol (UDP) to facilitate the sending of datagrams (self-contained
pieces of information) in an unreliable manner. Unreliable means that information sent via datagrams isn't guaranteed to make it
to its destination.
</p></li><li>
Stream Socket:<br>
<p>
A stream socket, or connected socket, is a socket through which data can be transmitted continuously. A stream socket is more
akin to a live network, in which the communication link is continuously active. A stream socket is a "connected" socket through
which data is transferred continuously.</p></li>
</div>

					<a href="https://www.inf.usi.ch/faculty/soule/teaching/2015-fall/netpl/lecture01-introduction.pdf" >for more info</a><br><a href="#back to top">back to top</a></p><br></li>

				<li id="section13"><h4>Symbolic</h4><p>In computer programming, symbolic programming is a programming paradigm in which the program can manipulate its own formulas and program components as if they were plain data.<br>Through symbolic programming, complex processes can be developed that build other more intricate processes by combining smaller units of logic or functionality. Thus, such programs can effectively modify themselves and appear to "learn", which makes them better suited for applications such as artificial intelligence, expert systems, natural language processing, and computer games.<br>Languages that support symbolic programming include homoiconic languages such as Wolfram Language,LISP and Prolog.<br>
<div>
	Symbolic computation deals with the computation of mathematical objects symbolically. This means that the mathematical objects
are represented exactly, not approximately, and mathematical expressions with unevaluated variables are left in symbolic form.<br>

It Covers the following:
<ul><li>
As A calculator and symbols
</li><li>
Algebraic Manipulations - Expand and Simplify
</li><li>Calculus – Limits, Differentiation, Series , Integration
</li><li>
Equation Solving – Matrices
</li></ul>
</div>
					<a href="#back to top">back to top</a></p><br></li>

				<li id="section14"><h4>Automata</h4><p>Automata-based programming is a programming paradigm in which the program or its part is thought of as a model of a finite state
machine or any other formal automation.
<br>
<div>
<ul>Automata Theory:<li>
Automata theory is the study of abstract computational devices
</li><li>
Abstract devices are (simplified) models of real computations
</li><li>
Computations happen everywhere: On your laptop, on your cell phone, in nature</li></ul><br>

Types of Automata
<ol><br><li>
Finite automata:<br>

Devices with a finite amount of memory.
Used to model “small” computers.
</li><br><li>
Push-down automata:<br>

Devices with infinite memory that can be
accessed in a restricted way.<br>Used to model parsers, etc.</li><br>

<li>
Turing
Machines:<br>

Devices with infinite memory.
<br>
Used to model any computer.</li>
</ol>
</div>
<a href="#back to top">back to top</a></p><br></li>

				<li id="section15"><h4>GUI</h4><p>In the 1980's, individuals started using computers. Typical applications included spreadsheets, word processors and computer aided design (CAD). Many of the people using these applications had no technical background. One consequence of this was that user interface design became important. It was no longer sufficient that a program work; in addition, it had to make its functionality accessible to users who did not have specialized training.<br>Many different user interfaces have been tried. One of the most successful is the graphical user interface (GUI). This is the kind of interface provided by the Macintosh, Motif, Tk, and Microsoft Windows. It includes a mouse and a graphical display, with windows, menus, dialog boxes, scroll bars and so on.<br>
<div>Some important points:
	<ul>
<li>A major task that a GUI designer needs to do is to determine what will happen when a GUI is invoked</li>
<li>
Every GUI component may generate different kinds of “events” when a user makes access to it using his mouse or keyboard
</li><li>
E.g. if a user moves his mouse on top of a button, an event of that button will be generated to the Windows system
</li><li>
E.g. if the user further clicks, then another event of that button will be generated (actually it is the click event)
</li><li>
For any event generated, the system will first check if there is an event handler, which defines the action for that event
</li></ul>

GUI Using Python
<ul><li>
Tkinter: Tkinter is the Python interface to the Tk GUI toolkit shipped with Python.
</li><li>
wxPython: This is an open-source Python interface for wxWindows
</li><li>
PyQt −This is also a Python interface for a popular cross-platform Qt GUI library.
</li><li>
JPython: JPython is a Python port for Java which gives Python scripts seamless access to Java class libraries on the local machine
</li></ul>
Tkinter Programming
<ul><li>
Tkinter is the standard GUI library for Python.
</li><li>
Creating a GUI application using Tkinter
	</li></ul></div>
					<a href="#back to top">back to top</a></p><br></li>
			</ol>
		</div>
		
		
	</div>


	<aside class="sidebar" role="complementary">
		<div class="wrapper">

			<div class="design-selection" id="design-selection">
				<nav role="navigation">
					<ul>
					<li>
						<a href="/219/" id="back to top" class="design-name">Select a programming paradigm</a>
					</li>					<li >
						<a href="#section1" class="design-name" >Structural</a> 
					</li>	
					</li>				<li>
						<a href="#section2" class="design-name" >Procedural</a>
					</li>					<li>
						<a href="#section3" class="design-name" >Object Oriented</a> 
					</li>					<li>
						<a href="#section4" class="design-name" >Event Driven</a> 
					</li>					<li>
						<a href="#section5" class="design-name">Declarative</a> 
					</li>					<li>
						<a href="#section6" class="design-name" >Imperative</a> 
					</li>					<li>
						<a href="#section7" class="design-name" >Parallel</a>
					</li>					<li>
						<a href="#section8" class="design-name" >Concurrent</a>
					</li>			
		<li>
						<a href="#section9" class="design-name">Functional</a>
					</li>					<li>
						<a href="#section10" class="design-name" >Logic</a>
					</li>					<li>
						<a href="#section11" class="design-name" >Dependent</a>
					</li>					<li>
						<a href="#section12" class="design-name" >Network</a>
					</li>					<li>
						<a href="#section13" class="design-name" >Symbolic</a>
					</li>					<li>
						<a href="#section14" class="design-name" >Automata</a>
					</li>					<li>
						<a href="#section15" class="design-name" >GUI</a>
					</li>					
							</ul>
				</nav>
			</div>

		<!--	<div class="design-archives" id="design-archives">
				<h3 class="archives">Archives:</h3>
				<nav role="navigation">
					<ul>
						<li class="next">
							<a href="/214/page1">
								Next Designs <span class="indicator">&rsaquo;</span>
							</a>
						</li>
						<li class="viewall">
							<a href="http://www.mezzoblue.com/zengarden/alldesigns/" title="View every submission to the Zen Garden.">
								View All Designs							</a>
						</li>
					</ul>
				</nav>
			</div>

			<div class="zen-resources" id="zen-resources">
				<h3 class="resources">Resources:</h3>
				<ul>
					<li class="view-css">
						<a href="style.css" title="View the source CSS file of the currently-viewed design.">
							View This Design&#8217;s <abbr title="Cascading Style Sheets">CSS</abbr>						</a>
					</li>
					<li class="css-resources">
						<a href="http://www.mezzoblue.com/zengarden/resources/" title="Links to great sites with information on using CSS.">
							<abbr title="Cascading Style Sheets">CSS</abbr> Resources						</a>
					</li>
					<li class="zen-faq">
						<a href="http://www.mezzoblue.com/zengarden/faq/" title="A list of Frequently Asked Questions about the Zen Garden.">
							<abbr title="Frequently Asked Questions">FAQ</abbr>						</a>
					</li>
					<li class="zen-submit">
						<a href="http://www.mezzoblue.com/zengarden/submit/" title="Send in your own CSS file.">
							Submit a Design						</a>
					</li>
					<li class="zen-translations">
						<a href="http://www.mezzoblue.com/zengarden/translations/" title="View translated versions of this page.">
							Translations						</a>
					</li>
				</ul>
			</div>
		</div>
	</aside>


</div> 
-->

<!--

	These superfluous divs/spans were originally provided as catch-alls to add extra imagery.
	These days we have full ::before and ::after support, favour using those instead.
	These only remain for historical design compatibility. They might go away one day.
		
-->


<div class="extra1" role="presentation"></div><div class="extra2" role="presentation"></div><div class="extra3" role="presentation"></div>
<div class="extra4" role="presentation"></div><div class="extra5" role="presentation"></div><div class="extra6" role="presentation"></div>

</body>
</html>
