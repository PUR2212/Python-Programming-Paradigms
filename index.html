<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>RA1811028010036</title>

<link rel="stylesheet" media="screen" href="style.css?v=8may2013">
	<link rel="alternate" type="application/rss+xml" title="RSS" href="file:///C:/Users/User/Desktop/web/purboshi.html">

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="author" content="Dave Shea">
	<meta name="description" content="A demonstration of what can be accomplished visually through CSS-based design.">
	<meta name="robots" content="all">


	<!--[if lt IE 9]>
	<script src="script/html5shiv.js"></script>
	<![endif]-->
</head>

<!--



	View source is a feature, not a bug. Thanks for your curiosity and
	interest in participating!

	Here are the submission guidelines for the new and improved csszengarden.com:

	- CSS3? Of course! Prefix for ALL browsers where necessary.
	- go responsive; test your layout at multiple screen sizes.
	- your browser testing baseline: IE9+, recent Chrome/Firefox/Safari, and iOS/Android
	- Graceful degradation is acceptable, and in fact highly encouraged.
	- use classes for styling. Don't use ids.
	- web fonts are cool, just make sure you have a license to share the files. Hosted 
	  services that are applied via the CSS file (ie. Google Fonts) will work fine, but
	  most that require custom HTML won't. TypeKit is supported, see the readme on this
	  page for usage instructions: https://github.com/mezzoblue/csszengarden.com/

	And a few tips on building your CSS file:

	- use :first-child, :last-child and :nth-child to get at non-classed elements
	- use ::before and ::after to create pseudo-elements for extra styling
	- use multiple background images to apply as many as you need to any element
	- use the Kellum Method for image replacement, if still needed. http://goo.gl/GXxdI
	- don't rely on the extra divs at the bottom. Use ::before and ::after instead.

		
-->

<body id="css-zen-garden">
<div class="page-wrapper">

	<section class="intro" id="zen-intro">
		<header role="banner">
			<h1>Purboshi Creations</h1>
			
		</header>

		<div class="summary" id="zen-summary" role="article">
			<p>Python is used successfully in thousands of real-world business applications around the world!</p>
			
		</div>
		<div>
<h1 >PYTHON LEARNING</h1>
</div>
<div  >
		
			<h2  >
				<p> <abbr> -PURBOSHI DAS  (RA1811028010036)</abbr> </p> 
			
			</h2>

		
</div>
		<div class="preamble" id="zen-preamble" role="article">
			<h3>Introduction</h3>
			<p>Python is an interpreted, high-level, general-purpose programming language. Created by Guido van Rossum and first released in 1991, Python's design philosophy emphasizes code readability with its notable use of significant whitespace. Its language constructs and object-oriented approach aim to help programmers write clear, logical code for small and large-scale projects.
			</p>
			
		</div>
	</section>

	<div class="main supporting" id="zen-supporting" role="main">
		<div class="explanation" id="zen-explanation" role="article">
			<h3>Programming Paradigms</h3>
			<p>Programming paradigms are a way to classify programming languages based on their features. Languages can be classified into multiple paradigms.

</p>
			<p>Some paradigms are concerned mainly with implications for the execution model of the language, such as allowing side effects, or whether the sequence of operations is defined by the execution model. Other paradigms are concerned mainly with the way that code is organized, such as grouping a code into units along with the state that is modified by the code. Yet others are concerned mainly with the style of syntax and grammar.</p>
		</div>

		<div class="participation" id="zen-participation" role="article">
			<h3>Overview</h3>
			<p>Just as software engineering (as a process) is defined by differing methodologies, so the programming languages (as models of computation) are defined by differing paradigms. Some languages are designed to support one paradigm (Smalltalk supports object-oriented programming, Haskell supports functional programming), while other programming languages support multiple paradigms (such as Object Pascal, C++, Java, JavaScript, C#, Scala, Visual Basic, Common Lisp, Scheme, Perl, PHP, Python, Ruby, Wolfram Language, Oz, and F#). For example, programs written in C++, Object Pascal or PHP can be purely procedural, purely object-oriented, or can contain elements of both or other paradigms. Software designers and programmers decide how to use those paradigm elements.</p>
			
		</div>

		<div class="benefits" id="zen-benefits" role="article">
			<h3>Criticism</h3>
			<p>Some programming language researchers criticise the notion of paradigms as a classification of programming languages, e.g. Harper, and Krishnamurthi. They argue that many programming languages cannot be strictly classified into one paradigm, but rather include features from several paradigms. See Comparison of multi-paradigm programming languages.</p>
		</div>

		<div class="requirements" id="zen-requirements" role="article">
			<h3>History</h3>
			<p>Different approaches to programming have developed over time, being identified as such either at the time or retrospectively. An early approach consciously identified as such is structured programming, advocated since the mid 1960s. The concept of a "programming paradigm" as such dates at least to 1978, in the Turing Award lecture of Robert W. Floyd, entitled The Paradigms of Programming, which cites the notion of paradigm as used by Thomas Kuhn in his The Structure of Scientific Revolutions (1962).</p>
		</div>

			<div class="benefits" id="zen-benefits" role="article">
				<h3 >Types of Programming Paradigms</h3>
			<ol>
				<li id="section1"><h4>Structural</h4><p>Structured programming is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making extensive use of the structured control flow constructs of selection (if/then/else) and repetition (while and for), block structures, and subroutines.<br>It is possible to do structured programming in any programming language, though it is preferable to use something like a procedural programming language. Some of the languages initially used for structured programming include: ALGOL, Pascal, PL/I and Ada, but most new procedural programming languages since that time have included features to encourage structured programming, and sometimes deliberately left out features – notably GOTO – in an effort to make unstructured programming more difficult. Structured programming (sometimes known as modular programming[citation needed]) enforces a logical structure on the program being written to make it more efficient and easier to understand and modify.<br><a href="#back to top">back to top</a></p><br></li>

				<li id="section2"><h4>Procedural</h4><p>Procedural programming is a programming paradigm, derived from structured programming,[citation needed] based on the concept of the procedure call. Procedures, also known as routines, subroutines, or functions, simply contain a series of computational steps to be carried out. Any given procedure might be called at any point during a program's execution, including by other procedures or itself. The first major procedural programming languages appeared circa 1957–1964, including Fortran, ALGOL, COBOL, PL/I and BASIC.Pascal and C were published circa 1970–1972.<br><a href="#back to top">back to top</a></p><br></li>

				<li id="section3"><h4>Object Oriented</h4><p>Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which can contain data, in the form of fields (often known as attributes or properties), and code, in the form of procedures (often known as methods). A feature of objects is an object's procedures that can access and often modify the data fields of the object with which they are associated (objects have a notion of "this" or "self").<br><a href="#back to top">back to top</a></p><br></li>

				<li id="section4"><h4>Event Driven</h4><p>In computer programming, event-driven programming is a programming paradigm in which the flow of the program is determined by events such as user actions (mouse clicks, key presses), sensor outputs, or messages from other programs or threads. Event-driven programming is the dominant paradigm used in graphical user interfaces and other applications (e.g., JavaScript web applications) that are centered on performing certain actions in response to user input. This is also true of programming for device drivers (e.g., P in USB device driver stacks).<br>In an event-driven application, there is generally a main loop that listens for events, and then triggers a callback function when one of those events is detected. In embedded systems, the same may be achieved using hardware interrupts instead of a constantly running main loop. Event-driven programs can be written in any programming language, although the task is easier in languages that provide high-level abstractions, such as await and closures.<br><a href="#back to top">back to top</a></p><br> </li>

				<li id="section5"><h4>Declarative</h4><p>In computer science, declarative programming is a programming paradigm—a style of building the structure and elements of computer programs—that expresses the logic of a computation without describing its control flow.<br>Many languages that apply this style attempt to minimize or eliminate side effects by describing what the program must accomplish in terms of the problem domain, rather than describe how to accomplish it as a sequence of the programming language primitives[2] (the how being left up to the language's implementation). This is in contrast with imperative programming, which implements algorithms in explicit steps.<br>Declarative programming often considers programs as theories of a formal logic, and computations as deductions in that logic space. Declarative programming may greatly simplify writing parallel programs.<br>Common declarative languages include those of database query languages (e.g., SQL, XQuery), regular expressions, logic programming, functional programming, and configuration management systems.<br><a href="#back to top">back to top</a></p><br></li>

				<li id="section6"><h4>Imperative</h4><p>In computer science, imperative programming is a programming paradigm that uses statements that change a program's state. In much the same way that the imperative mood in natural languages expresses commands, an imperative program consists of commands for the computer to perform. Imperative programming focuses on describing how a program operates.<br>The term is often used in contrast to declarative programming, which focuses on what the program should accomplish without specifying how the program should achieve the result.<br><a href="#back to top">back to top</a><br></p></li>

				<li id="section7"><h4>Parallel</h4><p>In computing, a parallel programming model is an abstraction of parallel computer architecture, with which it is convenient to express algorithms and their composition in programs. The value of a programming model can be judged on its generality: how well a range of different problems can be expressed for a variety of different architectures, and its performance: how efficiently the compiled programs can execute.The implementation of a parallel programming model can take the form of a library invoked from a sequential language, as an extension to an existing language, or as an entirely new language.<br>Consensus around a particular programming model is important because it leads to different parallel computers being built with support for the model, thereby facilitating portability of software. In this sense, programming models are referred to as bridging between hardware and software.[2]<br></p><a href="#back to top">back to top</a><br></li>

				<li id="section8"><h4>Concurrent</h4><p>Concurrent computing is a form of computing in which several computations are executed concurrently—during overlapping time periods—instead of sequentially, with one completing before the next starts.<br>This is a property of a system—whether a program, computer, or a network—where there is a separate execution point or "thread of control" for each process. A concurrent system is one where a computation can advance without waiting for all other computations to complete.<br>Concurrent computing is a form of modular programming. In its paradigm an overall computation is factored into subcomputations that may be executed concurrently.<br>Concurrent computations may be executed in parallel,[2][5] for example, by assigning each process to a separate processor or processor core, or distributing a computation across a network. In general, however, the languages, tools, and techniques for parallel programming might not be suitable for concurrent programming, and vice versa<br><a href="#back to top">back to top</a></p><br></li>

				<li id="section9"><h4>Functional</h4><p>Functional programming is a programming paradigm in which we try to bind everything in pure mathematical functions style. It is a declarative type of programming style. Its main focus is on “what to solve” in contrast to an imperative style where the main focus is “how to solve”. It uses expressions instead of statements. An expression is evaluated to produce a value whereas a statement is executed to assign variables.<br><a href="#back to top">back to top</a></p><br></li>

				<li id="section10"><h4>Logic</h4><p>Logic programming is a programming paradigm which is largely based on formal logic. Any program written in a logic programming language is a set of sentences in logical form, expressing facts and rules about some problem domain. Major logic programming language families include Prolog, answer set programming (ASP) and Datalog.<br><a href="#back to top">back to top</a></p><br></li>

				<li id="section11"><h4>Dependent</h4><p>In computer science and logic, a dependent type is a type whose definition depends on a value. It is an overlapping feature of type theory and type systems. In intuitionistic type theory, dependent types are used to encode logic's quantifiers like "for all" and "there exists". In functional programming languages like Agda, ATS, Coq, F*, Epigram, and Idris, dependent types may help reduce bugs by enabling the programmer to assign types that further restrain the set of possible implementations.<br>Two common examples of dependent types are dependent functions and dependent pairs. The return type of a dependent function may depend on the value (not just type) of one of its arguments. For instance, a function that takes a positive integer where the array length is part of the type of the array. A dependent pair may have a second value of which the type depends on the first value. Sticking with the array example, a dependent pair may be used to pair an array with its length in a type-safe way.<br>Dependent types add complexity to a type system. Deciding the equality of dependent types in a program may require computations. If arbitrary values are allowed in dependent types, then deciding type equality may involve deciding whether two arbitrary programs produce the same result; hence type checking may become undecidable.<a href="#back to top">back to top</a></p><br></li>

				<li id="section12"><h4>Network</h4><p>A programming language provides abstractions and ways to compose those abstractions.The programming languages you are familiar with are models of computer systems.They provide abstractions for data and computation.<br><a href="https://www.inf.usi.ch/faculty/soule/teaching/2015-fall/netpl/lecture01-introduction.pdf" >for more info</a><br><a href="#back to top">back to top</a></p><br></li>

				<li id="section13"><h4>Symbolic</h4><p>In computer programming, symbolic programming is a programming paradigm in which the program can manipulate its own formulas and program components as if they were plain data.<br>Through symbolic programming, complex processes can be developed that build other more intricate processes by combining smaller units of logic or functionality. Thus, such programs can effectively modify themselves and appear to "learn", which makes them better suited for applications such as artificial intelligence, expert systems, natural language processing, and computer games.<br>Languages that support symbolic programming include homoiconic languages such as Wolfram Language,LISP and Prolog.<br><a href="#back to top">back to top</a></p><br></li>

				<li id="section14"><h4>Automata</h4><p>Automata-based programming is a programming paradigm in which the program or part of it is thought of as a model of a finite-state machine (FSM) or any other (often more complicated) formal automaton.Sometimes a potentially infinite set of possible states is introduced, and such a set can have a complicated structure, not just an enumeration.<br><a href="#back to top">back to top</a></p><br></li>

				<li id="section15"><h4>GUI</h4><p>In the 1980's, individuals started using computers. Typical applications included spreadsheets, word processors and computer aided design (CAD). Many of the people using these applications had no technical background. One consequence of this was that user interface design became important. It was no longer sufficient that a program work; in addition, it had to make its functionality accessible to users who did not have specialized training.<br>Many different user interfaces have been tried. One of the most successful is the graphical user interface (GUI). This is the kind of interface provided by the Macintosh, Motif, Tk, and Microsoft Windows. It includes a mouse and a graphical display, with windows, menus, dialog boxes, scroll bars and so on.<br><a href="#back to top">back to top</a></p><br></li>
			</ol>
		</div>
		
		
	</div>


	<aside class="sidebar" role="complementary">
		<div class="wrapper">

			<div class="design-selection" id="design-selection">
				<nav role="navigation">
					<ul>
					<li>
						<a href="/219/" id="back to top" class="design-name">Select a programming paradigm</a>
					</li>					<li >
						<a href="#section1" class="design-name" >Structural</a> 
					</li>	
					</li>				<li>
						<a href="#section2" class="design-name" >Procedural</a>
					</li>					<li>
						<a href="#section3" class="design-name" >Object Oriented</a> 
					</li>					<li>
						<a href="#section4" class="design-name" >Event Driven</a> 
					</li>					<li>
						<a href="#section5" class="design-name">Declarative</a> 
					</li>					<li>
						<a href="#section6" class="design-name" >Imperative</a> 
					</li>					<li>
						<a href="#section7" class="design-name" >Parallel</a>
					</li>					<li>
						<a href="#section8" class="design-name" >Concurrent</a>
					</li>			
		<li>
						<a href="#section9" class="design-name">Functional</a>
					</li>					<li>
						<a href="#section10" class="design-name" >Logic</a>
					</li>					<li>
						<a href="#section11" class="design-name" >Dependent</a>
					</li>					<li>
						<a href="#section12" class="design-name" >Network</a>
					</li>					<li>
						<a href="#section13" class="design-name" >Symbolic</a>
					</li>					<li>
						<a href="#section14" class="design-name" >Automata</a>
					</li>					<li>
						<a href="#section15" class="design-name" >GUI</a>
					</li>					
							</ul>
				</nav>
			</div>

		<!--	<div class="design-archives" id="design-archives">
				<h3 class="archives">Archives:</h3>
				<nav role="navigation">
					<ul>
						<li class="next">
							<a href="/214/page1">
								Next Designs <span class="indicator">&rsaquo;</span>
							</a>
						</li>
						<li class="viewall">
							<a href="http://www.mezzoblue.com/zengarden/alldesigns/" title="View every submission to the Zen Garden.">
								View All Designs							</a>
						</li>
					</ul>
				</nav>
			</div>

			<div class="zen-resources" id="zen-resources">
				<h3 class="resources">Resources:</h3>
				<ul>
					<li class="view-css">
						<a href="style.css" title="View the source CSS file of the currently-viewed design.">
							View This Design&#8217;s <abbr title="Cascading Style Sheets">CSS</abbr>						</a>
					</li>
					<li class="css-resources">
						<a href="http://www.mezzoblue.com/zengarden/resources/" title="Links to great sites with information on using CSS.">
							<abbr title="Cascading Style Sheets">CSS</abbr> Resources						</a>
					</li>
					<li class="zen-faq">
						<a href="http://www.mezzoblue.com/zengarden/faq/" title="A list of Frequently Asked Questions about the Zen Garden.">
							<abbr title="Frequently Asked Questions">FAQ</abbr>						</a>
					</li>
					<li class="zen-submit">
						<a href="http://www.mezzoblue.com/zengarden/submit/" title="Send in your own CSS file.">
							Submit a Design						</a>
					</li>
					<li class="zen-translations">
						<a href="http://www.mezzoblue.com/zengarden/translations/" title="View translated versions of this page.">
							Translations						</a>
					</li>
				</ul>
			</div>
		</div>
	</aside>


</div> 
-->

<!--

	These superfluous divs/spans were originally provided as catch-alls to add extra imagery.
	These days we have full ::before and ::after support, favour using those instead.
	These only remain for historical design compatibility. They might go away one day.
		
-->
<div class="extra1" role="presentation"></div><div class="extra2" role="presentation"></div><div class="extra3" role="presentation"></div>
<div class="extra4" role="presentation"></div><div class="extra5" role="presentation"></div><div class="extra6" role="presentation"></div>

</body>
</html>
